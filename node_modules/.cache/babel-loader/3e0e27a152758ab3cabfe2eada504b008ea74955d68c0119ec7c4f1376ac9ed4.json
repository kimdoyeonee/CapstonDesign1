{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PacketLengthParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes packets with a delimiter and length of payload\n * specified within the data stream.\n * @extends Transform\n * @summary Decodes packets of the general form:\n *       [delimiter][len][payload0] ... [payload0 + len]\n *\n * The length field can be up to 4 bytes and can be at any offset within the packet\n *       [delimiter][header0][header1][len0][len1[payload0] ... [payload0 + len]\n *\n * The offset and number of bytes of the length field need to be provided in options\n * if not 1 byte immediately following the delimiter.\n */\nclass PacketLengthParser extends stream_1.Transform {\n  buffer;\n  start;\n  opts;\n  constructor(options = {}) {\n    super(options);\n    const {\n      delimiter = 0xaa,\n      packetOverhead = 2,\n      lengthBytes = 1,\n      lengthOffset = 1,\n      maxLen = 0xff\n    } = options;\n    this.opts = {\n      delimiter,\n      packetOverhead,\n      lengthBytes,\n      lengthOffset,\n      maxLen\n    };\n    this.buffer = Buffer.alloc(0);\n    this.start = false;\n  }\n  _transform(chunk, encoding, cb) {\n    for (let ndx = 0; ndx < chunk.length; ndx++) {\n      const byte = chunk[ndx];\n      if (byte === this.opts.delimiter) {\n        this.start = true;\n      }\n      if (true === this.start) {\n        this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n        if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {\n          const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);\n          if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {\n            this.push(this.buffer);\n            this.buffer = Buffer.alloc(0);\n            this.start = false;\n          }\n        }\n      }\n    }\n    cb();\n  }\n  _flush(cb) {\n    this.push(this.buffer);\n    this.buffer = Buffer.alloc(0);\n    cb();\n  }\n}\nexports.PacketLengthParser = PacketLengthParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","PacketLengthParser","stream_1","require","Transform","buffer","start","opts","constructor","options","delimiter","packetOverhead","lengthBytes","lengthOffset","maxLen","Buffer","alloc","_transform","chunk","encoding","cb","ndx","length","byte","concat","from","len","readUIntLE","push","_flush"],"sources":["/Users/kimdoyeon/Desktop/CapstonDesign1/node_modules/@serialport/parser-packet-length/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PacketLengthParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes packets with a delimiter and length of payload\n * specified within the data stream.\n * @extends Transform\n * @summary Decodes packets of the general form:\n *       [delimiter][len][payload0] ... [payload0 + len]\n *\n * The length field can be up to 4 bytes and can be at any offset within the packet\n *       [delimiter][header0][header1][len0][len1[payload0] ... [payload0 + len]\n *\n * The offset and number of bytes of the length field need to be provided in options\n * if not 1 byte immediately following the delimiter.\n */\nclass PacketLengthParser extends stream_1.Transform {\n    buffer;\n    start;\n    opts;\n    constructor(options = {}) {\n        super(options);\n        const { delimiter = 0xaa, packetOverhead = 2, lengthBytes = 1, lengthOffset = 1, maxLen = 0xff } = options;\n        this.opts = {\n            delimiter,\n            packetOverhead,\n            lengthBytes,\n            lengthOffset,\n            maxLen,\n        };\n        this.buffer = Buffer.alloc(0);\n        this.start = false;\n    }\n    _transform(chunk, encoding, cb) {\n        for (let ndx = 0; ndx < chunk.length; ndx++) {\n            const byte = chunk[ndx];\n            if (byte === this.opts.delimiter) {\n                this.start = true;\n            }\n            if (true === this.start) {\n                this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n                if (this.buffer.length >= this.opts.lengthOffset + this.opts.lengthBytes) {\n                    const len = this.buffer.readUIntLE(this.opts.lengthOffset, this.opts.lengthBytes);\n                    if (this.buffer.length == len + this.opts.packetOverhead || len > this.opts.maxLen) {\n                        this.push(this.buffer);\n                        this.buffer = Buffer.alloc(0);\n                        this.start = false;\n                    }\n                }\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.PacketLengthParser = PacketLengthParser;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,kBAAkB,GAAG,KAAK,CAAC;AACnC,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,kBAAkB,SAASC,QAAQ,CAACE,SAAS,CAAC;EAChDC,MAAM;EACNC,KAAK;EACLC,IAAI;EACJC,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACtB,KAAK,CAACA,OAAO,CAAC;IACd,MAAM;MAAEC,SAAS,GAAG,IAAI;MAAEC,cAAc,GAAG,CAAC;MAAEC,WAAW,GAAG,CAAC;MAAEC,YAAY,GAAG,CAAC;MAAEC,MAAM,GAAG;IAAK,CAAC,GAAGL,OAAO;IAC1G,IAAI,CAACF,IAAI,GAAG;MACRG,SAAS;MACTC,cAAc;MACdC,WAAW;MACXC,YAAY;MACZC;IACJ,CAAC;IACD,IAAI,CAACT,MAAM,GAAGU,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAC7B,IAAI,CAACV,KAAK,GAAG,KAAK;EACtB;EACAW,UAAUA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC5B,KAAK,IAAIC,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGH,KAAK,CAACI,MAAM,EAAED,GAAG,EAAE,EAAE;MACzC,MAAME,IAAI,GAAGL,KAAK,CAACG,GAAG,CAAC;MACvB,IAAIE,IAAI,KAAK,IAAI,CAAChB,IAAI,CAACG,SAAS,EAAE;QAC9B,IAAI,CAACJ,KAAK,GAAG,IAAI;MACrB;MACA,IAAI,IAAI,KAAK,IAAI,CAACA,KAAK,EAAE;QACrB,IAAI,CAACD,MAAM,GAAGU,MAAM,CAACS,MAAM,CAAC,CAAC,IAAI,CAACnB,MAAM,EAAEU,MAAM,CAACU,IAAI,CAAC,CAACF,IAAI,CAAC,CAAC,CAAC,CAAC;QAC/D,IAAI,IAAI,CAAClB,MAAM,CAACiB,MAAM,IAAI,IAAI,CAACf,IAAI,CAACM,YAAY,GAAG,IAAI,CAACN,IAAI,CAACK,WAAW,EAAE;UACtE,MAAMc,GAAG,GAAG,IAAI,CAACrB,MAAM,CAACsB,UAAU,CAAC,IAAI,CAACpB,IAAI,CAACM,YAAY,EAAE,IAAI,CAACN,IAAI,CAACK,WAAW,CAAC;UACjF,IAAI,IAAI,CAACP,MAAM,CAACiB,MAAM,IAAII,GAAG,GAAG,IAAI,CAACnB,IAAI,CAACI,cAAc,IAAIe,GAAG,GAAG,IAAI,CAACnB,IAAI,CAACO,MAAM,EAAE;YAChF,IAAI,CAACc,IAAI,CAAC,IAAI,CAACvB,MAAM,CAAC;YACtB,IAAI,CAACA,MAAM,GAAGU,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;YAC7B,IAAI,CAACV,KAAK,GAAG,KAAK;UACtB;QACJ;MACJ;IACJ;IACAc,EAAE,CAAC,CAAC;EACR;EACAS,MAAMA,CAACT,EAAE,EAAE;IACP,IAAI,CAACQ,IAAI,CAAC,IAAI,CAACvB,MAAM,CAAC;IACtB,IAAI,CAACA,MAAM,GAAGU,MAAM,CAACC,KAAK,CAAC,CAAC,CAAC;IAC7BI,EAAE,CAAC,CAAC;EACR;AACJ;AACArB,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB"},"metadata":{},"sourceType":"script","externalDependencies":[]}