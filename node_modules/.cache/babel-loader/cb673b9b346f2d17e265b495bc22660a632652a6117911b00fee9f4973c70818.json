{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SlipEncoder = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that emits SLIP-encoded data for each incoming packet.\n *\n * Runs in O(n) time, adding a 0xC0 character at the end of each\n * received packet and escaping characters, according to RFC 1055.\n */\nclass SlipEncoder extends stream_1.Transform {\n  opts;\n  constructor(options = {}) {\n    super(options);\n    const {\n      START,\n      ESC = 0xdb,\n      END = 0xc0,\n      ESC_START,\n      ESC_END = 0xdc,\n      ESC_ESC = 0xdd,\n      bluetoothQuirk = false\n    } = options;\n    this.opts = {\n      START,\n      ESC,\n      END,\n      ESC_START,\n      ESC_END,\n      ESC_ESC,\n      bluetoothQuirk\n    };\n  }\n  _transform(chunk, encoding, cb) {\n    const chunkLength = chunk.length;\n    if (this.opts.bluetoothQuirk && chunkLength === 0) {\n      // Edge case: push no data. Bluetooth-quirky SLIP parsers don't like\n      // lots of 0xC0s together.\n      return cb();\n    }\n    // Allocate memory for the worst-case scenario: all bytes are escaped,\n    // plus start and end separators.\n    const encoded = Buffer.alloc(chunkLength * 2 + 2);\n    let j = 0;\n    if (this.opts.bluetoothQuirk == true) {\n      encoded[j++] = this.opts.END;\n    }\n    if (this.opts.START !== undefined) {\n      encoded[j++] = this.opts.START;\n    }\n    for (let i = 0; i < chunkLength; i++) {\n      let byte = chunk[i];\n      if (byte === this.opts.START && this.opts.ESC_START) {\n        encoded[j++] = this.opts.ESC;\n        byte = this.opts.ESC_START;\n      } else if (byte === this.opts.END) {\n        encoded[j++] = this.opts.ESC;\n        byte = this.opts.ESC_END;\n      } else if (byte === this.opts.ESC) {\n        encoded[j++] = this.opts.ESC;\n        byte = this.opts.ESC_ESC;\n      }\n      encoded[j++] = byte;\n    }\n    encoded[j++] = this.opts.END;\n    cb(null, encoded.slice(0, j));\n  }\n}\nexports.SlipEncoder = SlipEncoder;","map":{"version":3,"names":["Object","defineProperty","exports","value","SlipEncoder","stream_1","require","Transform","opts","constructor","options","START","ESC","END","ESC_START","ESC_END","ESC_ESC","bluetoothQuirk","_transform","chunk","encoding","cb","chunkLength","length","encoded","Buffer","alloc","j","undefined","i","byte","slice"],"sources":["/Users/kimdoyeon/Desktop/CapstonDesign1/node_modules/@serialport/parser-slip-encoder/dist/encoder.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SlipEncoder = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that emits SLIP-encoded data for each incoming packet.\n *\n * Runs in O(n) time, adding a 0xC0 character at the end of each\n * received packet and escaping characters, according to RFC 1055.\n */\nclass SlipEncoder extends stream_1.Transform {\n    opts;\n    constructor(options = {}) {\n        super(options);\n        const { START, ESC = 0xdb, END = 0xc0, ESC_START, ESC_END = 0xdc, ESC_ESC = 0xdd, bluetoothQuirk = false } = options;\n        this.opts = {\n            START,\n            ESC,\n            END,\n            ESC_START,\n            ESC_END,\n            ESC_ESC,\n            bluetoothQuirk,\n        };\n    }\n    _transform(chunk, encoding, cb) {\n        const chunkLength = chunk.length;\n        if (this.opts.bluetoothQuirk && chunkLength === 0) {\n            // Edge case: push no data. Bluetooth-quirky SLIP parsers don't like\n            // lots of 0xC0s together.\n            return cb();\n        }\n        // Allocate memory for the worst-case scenario: all bytes are escaped,\n        // plus start and end separators.\n        const encoded = Buffer.alloc(chunkLength * 2 + 2);\n        let j = 0;\n        if (this.opts.bluetoothQuirk == true) {\n            encoded[j++] = this.opts.END;\n        }\n        if (this.opts.START !== undefined) {\n            encoded[j++] = this.opts.START;\n        }\n        for (let i = 0; i < chunkLength; i++) {\n            let byte = chunk[i];\n            if (byte === this.opts.START && this.opts.ESC_START) {\n                encoded[j++] = this.opts.ESC;\n                byte = this.opts.ESC_START;\n            }\n            else if (byte === this.opts.END) {\n                encoded[j++] = this.opts.ESC;\n                byte = this.opts.ESC_END;\n            }\n            else if (byte === this.opts.ESC) {\n                encoded[j++] = this.opts.ESC;\n                byte = this.opts.ESC_ESC;\n            }\n            encoded[j++] = byte;\n        }\n        encoded[j++] = this.opts.END;\n        cb(null, encoded.slice(0, j));\n    }\n}\nexports.SlipEncoder = SlipEncoder;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAC5B,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,MAAMF,WAAW,SAASC,QAAQ,CAACE,SAAS,CAAC;EACzCC,IAAI;EACJC,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IACtB,KAAK,CAACA,OAAO,CAAC;IACd,MAAM;MAAEC,KAAK;MAAEC,GAAG,GAAG,IAAI;MAAEC,GAAG,GAAG,IAAI;MAAEC,SAAS;MAAEC,OAAO,GAAG,IAAI;MAAEC,OAAO,GAAG,IAAI;MAAEC,cAAc,GAAG;IAAM,CAAC,GAAGP,OAAO;IACpH,IAAI,CAACF,IAAI,GAAG;MACRG,KAAK;MACLC,GAAG;MACHC,GAAG;MACHC,SAAS;MACTC,OAAO;MACPC,OAAO;MACPC;IACJ,CAAC;EACL;EACAC,UAAUA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC5B,MAAMC,WAAW,GAAGH,KAAK,CAACI,MAAM;IAChC,IAAI,IAAI,CAACf,IAAI,CAACS,cAAc,IAAIK,WAAW,KAAK,CAAC,EAAE;MAC/C;MACA;MACA,OAAOD,EAAE,CAAC,CAAC;IACf;IACA;IACA;IACA,MAAMG,OAAO,GAAGC,MAAM,CAACC,KAAK,CAACJ,WAAW,GAAG,CAAC,GAAG,CAAC,CAAC;IACjD,IAAIK,CAAC,GAAG,CAAC;IACT,IAAI,IAAI,CAACnB,IAAI,CAACS,cAAc,IAAI,IAAI,EAAE;MAClCO,OAAO,CAACG,CAAC,EAAE,CAAC,GAAG,IAAI,CAACnB,IAAI,CAACK,GAAG;IAChC;IACA,IAAI,IAAI,CAACL,IAAI,CAACG,KAAK,KAAKiB,SAAS,EAAE;MAC/BJ,OAAO,CAACG,CAAC,EAAE,CAAC,GAAG,IAAI,CAACnB,IAAI,CAACG,KAAK;IAClC;IACA,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,WAAW,EAAEO,CAAC,EAAE,EAAE;MAClC,IAAIC,IAAI,GAAGX,KAAK,CAACU,CAAC,CAAC;MACnB,IAAIC,IAAI,KAAK,IAAI,CAACtB,IAAI,CAACG,KAAK,IAAI,IAAI,CAACH,IAAI,CAACM,SAAS,EAAE;QACjDU,OAAO,CAACG,CAAC,EAAE,CAAC,GAAG,IAAI,CAACnB,IAAI,CAACI,GAAG;QAC5BkB,IAAI,GAAG,IAAI,CAACtB,IAAI,CAACM,SAAS;MAC9B,CAAC,MACI,IAAIgB,IAAI,KAAK,IAAI,CAACtB,IAAI,CAACK,GAAG,EAAE;QAC7BW,OAAO,CAACG,CAAC,EAAE,CAAC,GAAG,IAAI,CAACnB,IAAI,CAACI,GAAG;QAC5BkB,IAAI,GAAG,IAAI,CAACtB,IAAI,CAACO,OAAO;MAC5B,CAAC,MACI,IAAIe,IAAI,KAAK,IAAI,CAACtB,IAAI,CAACI,GAAG,EAAE;QAC7BY,OAAO,CAACG,CAAC,EAAE,CAAC,GAAG,IAAI,CAACnB,IAAI,CAACI,GAAG;QAC5BkB,IAAI,GAAG,IAAI,CAACtB,IAAI,CAACQ,OAAO;MAC5B;MACAQ,OAAO,CAACG,CAAC,EAAE,CAAC,GAAGG,IAAI;IACvB;IACAN,OAAO,CAACG,CAAC,EAAE,CAAC,GAAG,IAAI,CAACnB,IAAI,CAACK,GAAG;IAC5BQ,EAAE,CAAC,IAAI,EAAEG,OAAO,CAACO,KAAK,CAAC,CAAC,EAAEJ,CAAC,CAAC,CAAC;EACjC;AACJ;AACAzB,OAAO,CAACE,WAAW,GAAGA,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}