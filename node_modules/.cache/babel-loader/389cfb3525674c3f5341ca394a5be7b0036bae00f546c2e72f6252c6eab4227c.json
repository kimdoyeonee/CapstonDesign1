{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nvar debugFactory = require('debug');\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\nvar debugFactory__default = /*#__PURE__*/_interopDefaultLegacy(debugFactory);\nconst debug = debugFactory__default[\"default\"]('serialport/binding-mock');\nlet ports = {};\nlet serialNumber = 0;\nfunction resolveNextTick() {\n  return new Promise(resolve => process.nextTick(() => resolve()));\n}\nclass CanceledError extends Error {\n  constructor(message) {\n    super(message);\n    this.canceled = true;\n  }\n}\nconst MockBinding = {\n  reset() {\n    ports = {};\n    serialNumber = 0;\n  },\n  // Create a mock port\n  createPort(path, options = {}) {\n    serialNumber++;\n    const optWithDefaults = Object.assign({\n      echo: false,\n      record: false,\n      manufacturer: 'The J5 Robotics Company',\n      vendorId: undefined,\n      productId: undefined,\n      maxReadSize: 1024\n    }, options);\n    ports[path] = {\n      data: Buffer.alloc(0),\n      echo: optWithDefaults.echo,\n      record: optWithDefaults.record,\n      readyData: optWithDefaults.readyData,\n      maxReadSize: optWithDefaults.maxReadSize,\n      info: {\n        path,\n        manufacturer: optWithDefaults.manufacturer,\n        serialNumber: `${serialNumber}`,\n        pnpId: undefined,\n        locationId: undefined,\n        vendorId: optWithDefaults.vendorId,\n        productId: optWithDefaults.productId\n      }\n    };\n    debug(serialNumber, 'created port', JSON.stringify({\n      path,\n      opt: options\n    }));\n  },\n  async list() {\n    debug(null, 'list');\n    return Object.values(ports).map(port => port.info);\n  },\n  async open(options) {\n    var _a;\n    if (!options || typeof options !== 'object' || Array.isArray(options)) {\n      throw new TypeError('\"options\" is not an object');\n    }\n    if (!options.path) {\n      throw new TypeError('\"path\" is not a valid port');\n    }\n    if (!options.baudRate) {\n      throw new TypeError('\"baudRate\" is not a valid baudRate');\n    }\n    const openOptions = Object.assign({\n      dataBits: 8,\n      lock: true,\n      stopBits: 1,\n      parity: 'none',\n      rtscts: false,\n      xon: false,\n      xoff: false,\n      xany: false,\n      hupcl: true\n    }, options);\n    const {\n      path\n    } = openOptions;\n    debug(null, `open: opening path ${path}`);\n    const port = ports[path];\n    await resolveNextTick();\n    if (!port) {\n      throw new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);\n    }\n    const serialNumber = port.info.serialNumber;\n    if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {\n      debug(serialNumber, 'open: Port is locked cannot open');\n      throw new Error('Port is locked cannot open');\n    }\n    debug(serialNumber, `open: opened path ${path}`);\n    port.openOpt = Object.assign({}, openOptions);\n    return new MockPortBinding(port, openOptions);\n  }\n};\n/**\n * Mock bindings for pretend serialport access\n */\nclass MockPortBinding {\n  constructor(port, openOptions) {\n    this.port = port;\n    this.openOptions = openOptions;\n    this.pendingRead = null;\n    this.isOpen = true;\n    this.lastWrite = null;\n    this.recording = Buffer.alloc(0);\n    this.writeOperation = null; // in flight promise or null\n    this.serialNumber = port.info.serialNumber;\n    if (port.readyData) {\n      const data = port.readyData;\n      process.nextTick(() => {\n        if (this.isOpen) {\n          debug(this.serialNumber, 'emitting ready data');\n          this.emitData(data);\n        }\n      });\n    }\n  }\n  // Emit data on a mock port\n  emitData(data) {\n    if (!this.isOpen || !this.port) {\n      throw new Error('Port must be open to pretend to receive data');\n    }\n    const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);\n    debug(this.serialNumber, 'emitting data - pending read:', Boolean(this.pendingRead));\n    this.port.data = Buffer.concat([this.port.data, bufferData]);\n    if (this.pendingRead) {\n      process.nextTick(this.pendingRead);\n      this.pendingRead = null;\n    }\n  }\n  async close() {\n    debug(this.serialNumber, 'close');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    const port = this.port;\n    if (!port) {\n      throw new Error('already closed');\n    }\n    port.openOpt = undefined;\n    // reset data on close\n    port.data = Buffer.alloc(0);\n    debug(this.serialNumber, 'port is closed');\n    this.serialNumber = undefined;\n    this.isOpen = false;\n    if (this.pendingRead) {\n      this.pendingRead(new CanceledError('port is closed'));\n    }\n  }\n  async read(buffer, offset, length) {\n    if (!Buffer.isBuffer(buffer)) {\n      throw new TypeError('\"buffer\" is not a Buffer');\n    }\n    if (typeof offset !== 'number' || isNaN(offset)) {\n      throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n    }\n    if (typeof length !== 'number' || isNaN(length)) {\n      throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n    }\n    if (buffer.length < offset + length) {\n      throw new Error('buffer is too small');\n    }\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    debug(this.serialNumber, 'read', length, 'bytes');\n    await resolveNextTick();\n    if (!this.isOpen || !this.port) {\n      throw new CanceledError('Read canceled');\n    }\n    if (this.port.data.length <= 0) {\n      return new Promise((resolve, reject) => {\n        this.pendingRead = err => {\n          if (err) {\n            return reject(err);\n          }\n          this.read(buffer, offset, length).then(resolve, reject);\n        };\n      });\n    }\n    const lengthToRead = this.port.maxReadSize > length ? length : this.port.maxReadSize;\n    const data = this.port.data.slice(0, lengthToRead);\n    const bytesRead = data.copy(buffer, offset);\n    this.port.data = this.port.data.slice(lengthToRead);\n    debug(this.serialNumber, 'read', bytesRead, 'bytes');\n    return {\n      bytesRead,\n      buffer\n    };\n  }\n  async write(buffer) {\n    if (!Buffer.isBuffer(buffer)) {\n      throw new TypeError('\"buffer\" is not a Buffer');\n    }\n    if (!this.isOpen || !this.port) {\n      debug('write', 'error port is not open');\n      throw new Error('Port is not open');\n    }\n    debug(this.serialNumber, 'write', buffer.length, 'bytes');\n    if (this.writeOperation) {\n      throw new Error('Overlapping writes are not supported and should be queued by the serialport object');\n    }\n    this.writeOperation = (async () => {\n      await resolveNextTick();\n      if (!this.isOpen || !this.port) {\n        throw new Error('Write canceled');\n      }\n      const data = this.lastWrite = Buffer.from(buffer); // copy\n      if (this.port.record) {\n        this.recording = Buffer.concat([this.recording, data]);\n      }\n      if (this.port.echo) {\n        process.nextTick(() => {\n          if (this.isOpen) {\n            this.emitData(data);\n          }\n        });\n      }\n      this.writeOperation = null;\n      debug(this.serialNumber, 'writing finished');\n    })();\n    return this.writeOperation;\n  }\n  async update(options) {\n    if (typeof options !== 'object') {\n      throw TypeError('\"options\" is not an object');\n    }\n    if (typeof options.baudRate !== 'number') {\n      throw new TypeError('\"options.baudRate\" is not a number');\n    }\n    debug(this.serialNumber, 'update');\n    if (!this.isOpen || !this.port) {\n      throw new Error('Port is not open');\n    }\n    await resolveNextTick();\n    if (this.port.openOpt) {\n      this.port.openOpt.baudRate = options.baudRate;\n    }\n  }\n  async set(options) {\n    if (typeof options !== 'object') {\n      throw new TypeError('\"options\" is not an object');\n    }\n    debug(this.serialNumber, 'set');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    await resolveNextTick();\n  }\n  async get() {\n    debug(this.serialNumber, 'get');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    await resolveNextTick();\n    return {\n      cts: true,\n      dsr: false,\n      dcd: false\n    };\n  }\n  async getBaudRate() {\n    var _a;\n    debug(this.serialNumber, 'getBaudRate');\n    if (!this.isOpen || !this.port) {\n      throw new Error('Port is not open');\n    }\n    await resolveNextTick();\n    if (!((_a = this.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {\n      throw new Error('Internal Error');\n    }\n    return {\n      baudRate: this.port.openOpt.baudRate\n    };\n  }\n  async flush() {\n    debug(this.serialNumber, 'flush');\n    if (!this.isOpen || !this.port) {\n      throw new Error('Port is not open');\n    }\n    await resolveNextTick();\n    this.port.data = Buffer.alloc(0);\n  }\n  async drain() {\n    debug(this.serialNumber, 'drain');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    await this.writeOperation;\n    await resolveNextTick();\n  }\n}\nexports.CanceledError = CanceledError;\nexports.MockBinding = MockBinding;\nexports.MockPortBinding = MockPortBinding;","map":{"version":3,"names":["Object","defineProperty","exports","value","debugFactory","require","_interopDefaultLegacy","e","debugFactory__default","debug","ports","serialNumber","resolveNextTick","Promise","resolve","process","nextTick","CanceledError","Error","constructor","message","canceled","MockBinding","reset","createPort","path","options","optWithDefaults","assign","echo","record","manufacturer","vendorId","undefined","productId","maxReadSize","data","Buffer","alloc","readyData","info","pnpId","locationId","JSON","stringify","opt","list","values","map","port","open","_a","Array","isArray","TypeError","baudRate","openOptions","dataBits","lock","stopBits","parity","rtscts","xon","xoff","xany","hupcl","openOpt","MockPortBinding","pendingRead","isOpen","lastWrite","recording","writeOperation","emitData","bufferData","isBuffer","from","Boolean","concat","close","read","buffer","offset","length","isNaN","reject","err","then","lengthToRead","slice","bytesRead","copy","write","update","set","get","cts","dsr","dcd","getBaudRate","flush","drain"],"sources":["/Users/kimdoyeon/Desktop/CapstonDesign1/node_modules/@serialport/binding-mock/dist/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar debugFactory = require('debug');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar debugFactory__default = /*#__PURE__*/_interopDefaultLegacy(debugFactory);\n\nconst debug = debugFactory__default[\"default\"]('serialport/binding-mock');\nlet ports = {};\nlet serialNumber = 0;\nfunction resolveNextTick() {\n    return new Promise(resolve => process.nextTick(() => resolve()));\n}\nclass CanceledError extends Error {\n    constructor(message) {\n        super(message);\n        this.canceled = true;\n    }\n}\nconst MockBinding = {\n    reset() {\n        ports = {};\n        serialNumber = 0;\n    },\n    // Create a mock port\n    createPort(path, options = {}) {\n        serialNumber++;\n        const optWithDefaults = Object.assign({ echo: false, record: false, manufacturer: 'The J5 Robotics Company', vendorId: undefined, productId: undefined, maxReadSize: 1024 }, options);\n        ports[path] = {\n            data: Buffer.alloc(0),\n            echo: optWithDefaults.echo,\n            record: optWithDefaults.record,\n            readyData: optWithDefaults.readyData,\n            maxReadSize: optWithDefaults.maxReadSize,\n            info: {\n                path,\n                manufacturer: optWithDefaults.manufacturer,\n                serialNumber: `${serialNumber}`,\n                pnpId: undefined,\n                locationId: undefined,\n                vendorId: optWithDefaults.vendorId,\n                productId: optWithDefaults.productId,\n            },\n        };\n        debug(serialNumber, 'created port', JSON.stringify({ path, opt: options }));\n    },\n    async list() {\n        debug(null, 'list');\n        return Object.values(ports).map(port => port.info);\n    },\n    async open(options) {\n        var _a;\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        if (!options.path) {\n            throw new TypeError('\"path\" is not a valid port');\n        }\n        if (!options.baudRate) {\n            throw new TypeError('\"baudRate\" is not a valid baudRate');\n        }\n        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: 'none', rtscts: false, xon: false, xoff: false, xany: false, hupcl: true }, options);\n        const { path } = openOptions;\n        debug(null, `open: opening path ${path}`);\n        const port = ports[path];\n        await resolveNextTick();\n        if (!port) {\n            throw new Error(`Port does not exist - please call MockBinding.createPort('${path}') first`);\n        }\n        const serialNumber = port.info.serialNumber;\n        if ((_a = port.openOpt) === null || _a === void 0 ? void 0 : _a.lock) {\n            debug(serialNumber, 'open: Port is locked cannot open');\n            throw new Error('Port is locked cannot open');\n        }\n        debug(serialNumber, `open: opened path ${path}`);\n        port.openOpt = Object.assign({}, openOptions);\n        return new MockPortBinding(port, openOptions);\n    },\n};\n/**\n * Mock bindings for pretend serialport access\n */\nclass MockPortBinding {\n    constructor(port, openOptions) {\n        this.port = port;\n        this.openOptions = openOptions;\n        this.pendingRead = null;\n        this.isOpen = true;\n        this.lastWrite = null;\n        this.recording = Buffer.alloc(0);\n        this.writeOperation = null; // in flight promise or null\n        this.serialNumber = port.info.serialNumber;\n        if (port.readyData) {\n            const data = port.readyData;\n            process.nextTick(() => {\n                if (this.isOpen) {\n                    debug(this.serialNumber, 'emitting ready data');\n                    this.emitData(data);\n                }\n            });\n        }\n    }\n    // Emit data on a mock port\n    emitData(data) {\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port must be open to pretend to receive data');\n        }\n        const bufferData = Buffer.isBuffer(data) ? data : Buffer.from(data);\n        debug(this.serialNumber, 'emitting data - pending read:', Boolean(this.pendingRead));\n        this.port.data = Buffer.concat([this.port.data, bufferData]);\n        if (this.pendingRead) {\n            process.nextTick(this.pendingRead);\n            this.pendingRead = null;\n        }\n    }\n    async close() {\n        debug(this.serialNumber, 'close');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        const port = this.port;\n        if (!port) {\n            throw new Error('already closed');\n        }\n        port.openOpt = undefined;\n        // reset data on close\n        port.data = Buffer.alloc(0);\n        debug(this.serialNumber, 'port is closed');\n        this.serialNumber = undefined;\n        this.isOpen = false;\n        if (this.pendingRead) {\n            this.pendingRead(new CanceledError('port is closed'));\n        }\n    }\n    async read(buffer, offset, length) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (typeof offset !== 'number' || isNaN(offset)) {\n            throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n        }\n        if (typeof length !== 'number' || isNaN(length)) {\n            throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n        }\n        if (buffer.length < offset + length) {\n            throw new Error('buffer is too small');\n        }\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        debug(this.serialNumber, 'read', length, 'bytes');\n        await resolveNextTick();\n        if (!this.isOpen || !this.port) {\n            throw new CanceledError('Read canceled');\n        }\n        if (this.port.data.length <= 0) {\n            return new Promise((resolve, reject) => {\n                this.pendingRead = err => {\n                    if (err) {\n                        return reject(err);\n                    }\n                    this.read(buffer, offset, length).then(resolve, reject);\n                };\n            });\n        }\n        const lengthToRead = this.port.maxReadSize > length ? length : this.port.maxReadSize;\n        const data = this.port.data.slice(0, lengthToRead);\n        const bytesRead = data.copy(buffer, offset);\n        this.port.data = this.port.data.slice(lengthToRead);\n        debug(this.serialNumber, 'read', bytesRead, 'bytes');\n        return { bytesRead, buffer };\n    }\n    async write(buffer) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (!this.isOpen || !this.port) {\n            debug('write', 'error port is not open');\n            throw new Error('Port is not open');\n        }\n        debug(this.serialNumber, 'write', buffer.length, 'bytes');\n        if (this.writeOperation) {\n            throw new Error('Overlapping writes are not supported and should be queued by the serialport object');\n        }\n        this.writeOperation = (async () => {\n            await resolveNextTick();\n            if (!this.isOpen || !this.port) {\n                throw new Error('Write canceled');\n            }\n            const data = (this.lastWrite = Buffer.from(buffer)); // copy\n            if (this.port.record) {\n                this.recording = Buffer.concat([this.recording, data]);\n            }\n            if (this.port.echo) {\n                process.nextTick(() => {\n                    if (this.isOpen) {\n                        this.emitData(data);\n                    }\n                });\n            }\n            this.writeOperation = null;\n            debug(this.serialNumber, 'writing finished');\n        })();\n        return this.writeOperation;\n    }\n    async update(options) {\n        if (typeof options !== 'object') {\n            throw TypeError('\"options\" is not an object');\n        }\n        if (typeof options.baudRate !== 'number') {\n            throw new TypeError('\"options.baudRate\" is not a number');\n        }\n        debug(this.serialNumber, 'update');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        if (this.port.openOpt) {\n            this.port.openOpt.baudRate = options.baudRate;\n        }\n    }\n    async set(options) {\n        if (typeof options !== 'object') {\n            throw new TypeError('\"options\" is not an object');\n        }\n        debug(this.serialNumber, 'set');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n    }\n    async get() {\n        debug(this.serialNumber, 'get');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        return {\n            cts: true,\n            dsr: false,\n            dcd: false,\n        };\n    }\n    async getBaudRate() {\n        var _a;\n        debug(this.serialNumber, 'getBaudRate');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        if (!((_a = this.port.openOpt) === null || _a === void 0 ? void 0 : _a.baudRate)) {\n            throw new Error('Internal Error');\n        }\n        return {\n            baudRate: this.port.openOpt.baudRate,\n        };\n    }\n    async flush() {\n        debug(this.serialNumber, 'flush');\n        if (!this.isOpen || !this.port) {\n            throw new Error('Port is not open');\n        }\n        await resolveNextTick();\n        this.port.data = Buffer.alloc(0);\n    }\n    async drain() {\n        debug(this.serialNumber, 'drain');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await this.writeOperation;\n        await resolveNextTick();\n    }\n}\n\nexports.CanceledError = CanceledError;\nexports.MockBinding = MockBinding;\nexports.MockPortBinding = MockPortBinding;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}