{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WindowsPortBinding = exports.WindowsBinding = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst _1 = require(\".\");\nconst load_bindings_1 = require(\"./load-bindings\");\nconst win32_sn_parser_1 = require(\"./win32-sn-parser\");\nconst debug = (0, debug_1.default)('serialport/bindings-cpp');\nexports.WindowsBinding = {\n  async list() {\n    const ports = await (0, load_bindings_1.asyncList)();\n    // Grab the serial number from the pnp id\n    return ports.map(port => {\n      if (port.pnpId && !port.serialNumber) {\n        const serialNumber = (0, win32_sn_parser_1.serialNumParser)(port.pnpId);\n        if (serialNumber) {\n          return Object.assign(Object.assign({}, port), {\n            serialNumber\n          });\n        }\n      }\n      return port;\n    });\n  },\n  async open(options) {\n    if (!options || typeof options !== 'object' || Array.isArray(options)) {\n      throw new TypeError('\"options\" is not an object');\n    }\n    if (!options.path) {\n      throw new TypeError('\"path\" is not a valid port');\n    }\n    if (!options.baudRate) {\n      throw new TypeError('\"baudRate\" is not a valid baudRate');\n    }\n    debug('open');\n    const openOptions = Object.assign({\n      dataBits: 8,\n      lock: true,\n      stopBits: 1,\n      parity: 'none',\n      rtscts: false,\n      rtsMode: 'handshake',\n      xon: false,\n      xoff: false,\n      xany: false,\n      hupcl: true\n    }, options);\n    const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);\n    return new WindowsPortBinding(fd, openOptions);\n  }\n};\n/**\n * The Windows binding layer\n */\nclass WindowsPortBinding {\n  constructor(fd, options) {\n    this.fd = fd;\n    this.openOptions = options;\n    this.writeOperation = null;\n  }\n  get isOpen() {\n    return this.fd !== null;\n  }\n  async close() {\n    debug('close');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    const fd = this.fd;\n    this.fd = null;\n    await (0, load_bindings_1.asyncClose)(fd);\n  }\n  async read(buffer, offset, length) {\n    if (!Buffer.isBuffer(buffer)) {\n      throw new TypeError('\"buffer\" is not a Buffer');\n    }\n    if (typeof offset !== 'number' || isNaN(offset)) {\n      throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n    }\n    if (typeof length !== 'number' || isNaN(length)) {\n      throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n    }\n    debug('read');\n    if (buffer.length < offset + length) {\n      throw new Error('buffer is too small');\n    }\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    try {\n      const bytesRead = await (0, load_bindings_1.asyncRead)(this.fd, buffer, offset, length);\n      return {\n        bytesRead,\n        buffer\n      };\n    } catch (err) {\n      if (!this.isOpen) {\n        throw new _1.BindingsError(err.message, {\n          canceled: true\n        });\n      }\n      throw err;\n    }\n  }\n  async write(buffer) {\n    if (!Buffer.isBuffer(buffer)) {\n      throw new TypeError('\"buffer\" is not a Buffer');\n    }\n    debug('write', buffer.length, 'bytes');\n    if (!this.isOpen) {\n      debug('write', 'error port is not open');\n      throw new Error('Port is not open');\n    }\n    this.writeOperation = (async () => {\n      if (buffer.length === 0) {\n        return;\n      }\n      await (0, load_bindings_1.asyncWrite)(this.fd, buffer);\n      this.writeOperation = null;\n    })();\n    return this.writeOperation;\n  }\n  async update(options) {\n    if (!options || typeof options !== 'object' || Array.isArray(options)) {\n      throw TypeError('\"options\" is not an object');\n    }\n    if (typeof options.baudRate !== 'number') {\n      throw new TypeError('\"options.baudRate\" is not a number');\n    }\n    debug('update');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    await (0, load_bindings_1.asyncUpdate)(this.fd, options);\n  }\n  async set(options) {\n    if (!options || typeof options !== 'object' || Array.isArray(options)) {\n      throw new TypeError('\"options\" is not an object');\n    }\n    debug('set', options);\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    await (0, load_bindings_1.asyncSet)(this.fd, options);\n  }\n  async get() {\n    debug('get');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    return (0, load_bindings_1.asyncGet)(this.fd);\n  }\n  async getBaudRate() {\n    debug('getBaudRate');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    return (0, load_bindings_1.asyncGetBaudRate)(this.fd);\n  }\n  async flush() {\n    debug('flush');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    await (0, load_bindings_1.asyncFlush)(this.fd);\n  }\n  async drain() {\n    debug('drain');\n    if (!this.isOpen) {\n      throw new Error('Port is not open');\n    }\n    await this.writeOperation;\n    await (0, load_bindings_1.asyncDrain)(this.fd);\n  }\n}\nexports.WindowsPortBinding = WindowsPortBinding;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","WindowsPortBinding","WindowsBinding","debug_1","require","_1","load_bindings_1","win32_sn_parser_1","debug","default","list","ports","asyncList","map","port","pnpId","serialNumber","serialNumParser","assign","open","options","Array","isArray","TypeError","path","baudRate","openOptions","dataBits","lock","stopBits","parity","rtscts","rtsMode","xon","xoff","xany","hupcl","fd","asyncOpen","constructor","writeOperation","isOpen","close","Error","asyncClose","read","buffer","offset","length","Buffer","isBuffer","isNaN","bytesRead","asyncRead","err","BindingsError","message","canceled","write","asyncWrite","update","asyncUpdate","set","asyncSet","get","asyncGet","getBaudRate","asyncGetBaudRate","flush","asyncFlush","drain","asyncDrain"],"sources":["/Users/kimdoyeon/Desktop/CapstonDesign1/node_modules/@serialport/bindings-cpp/dist/win32.js"],"sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WindowsPortBinding = exports.WindowsBinding = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst _1 = require(\".\");\nconst load_bindings_1 = require(\"./load-bindings\");\nconst win32_sn_parser_1 = require(\"./win32-sn-parser\");\nconst debug = (0, debug_1.default)('serialport/bindings-cpp');\nexports.WindowsBinding = {\n    async list() {\n        const ports = await (0, load_bindings_1.asyncList)();\n        // Grab the serial number from the pnp id\n        return ports.map(port => {\n            if (port.pnpId && !port.serialNumber) {\n                const serialNumber = (0, win32_sn_parser_1.serialNumParser)(port.pnpId);\n                if (serialNumber) {\n                    return Object.assign(Object.assign({}, port), { serialNumber });\n                }\n            }\n            return port;\n        });\n    },\n    async open(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        if (!options.path) {\n            throw new TypeError('\"path\" is not a valid port');\n        }\n        if (!options.baudRate) {\n            throw new TypeError('\"baudRate\" is not a valid baudRate');\n        }\n        debug('open');\n        const openOptions = Object.assign({ dataBits: 8, lock: true, stopBits: 1, parity: 'none', rtscts: false, rtsMode: 'handshake', xon: false, xoff: false, xany: false, hupcl: true }, options);\n        const fd = await (0, load_bindings_1.asyncOpen)(openOptions.path, openOptions);\n        return new WindowsPortBinding(fd, openOptions);\n    },\n};\n/**\n * The Windows binding layer\n */\nclass WindowsPortBinding {\n    constructor(fd, options) {\n        this.fd = fd;\n        this.openOptions = options;\n        this.writeOperation = null;\n    }\n    get isOpen() {\n        return this.fd !== null;\n    }\n    async close() {\n        debug('close');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        const fd = this.fd;\n        this.fd = null;\n        await (0, load_bindings_1.asyncClose)(fd);\n    }\n    async read(buffer, offset, length) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        if (typeof offset !== 'number' || isNaN(offset)) {\n            throw new TypeError(`\"offset\" is not an integer got \"${isNaN(offset) ? 'NaN' : typeof offset}\"`);\n        }\n        if (typeof length !== 'number' || isNaN(length)) {\n            throw new TypeError(`\"length\" is not an integer got \"${isNaN(length) ? 'NaN' : typeof length}\"`);\n        }\n        debug('read');\n        if (buffer.length < offset + length) {\n            throw new Error('buffer is too small');\n        }\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        try {\n            const bytesRead = await (0, load_bindings_1.asyncRead)(this.fd, buffer, offset, length);\n            return { bytesRead, buffer };\n        }\n        catch (err) {\n            if (!this.isOpen) {\n                throw new _1.BindingsError(err.message, { canceled: true });\n            }\n            throw err;\n        }\n    }\n    async write(buffer) {\n        if (!Buffer.isBuffer(buffer)) {\n            throw new TypeError('\"buffer\" is not a Buffer');\n        }\n        debug('write', buffer.length, 'bytes');\n        if (!this.isOpen) {\n            debug('write', 'error port is not open');\n            throw new Error('Port is not open');\n        }\n        this.writeOperation = (async () => {\n            if (buffer.length === 0) {\n                return;\n            }\n            await (0, load_bindings_1.asyncWrite)(this.fd, buffer);\n            this.writeOperation = null;\n        })();\n        return this.writeOperation;\n    }\n    async update(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw TypeError('\"options\" is not an object');\n        }\n        if (typeof options.baudRate !== 'number') {\n            throw new TypeError('\"options.baudRate\" is not a number');\n        }\n        debug('update');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncUpdate)(this.fd, options);\n    }\n    async set(options) {\n        if (!options || typeof options !== 'object' || Array.isArray(options)) {\n            throw new TypeError('\"options\" is not an object');\n        }\n        debug('set', options);\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncSet)(this.fd, options);\n    }\n    async get() {\n        debug('get');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, load_bindings_1.asyncGet)(this.fd);\n    }\n    async getBaudRate() {\n        debug('getBaudRate');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        return (0, load_bindings_1.asyncGetBaudRate)(this.fd);\n    }\n    async flush() {\n        debug('flush');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await (0, load_bindings_1.asyncFlush)(this.fd);\n    }\n    async drain() {\n        debug('drain');\n        if (!this.isOpen) {\n            throw new Error('Port is not open');\n        }\n        await this.writeOperation;\n        await (0, load_bindings_1.asyncDrain)(this.fd);\n    }\n}\nexports.WindowsPortBinding = WindowsPortBinding;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}