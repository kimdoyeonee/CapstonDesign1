{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SpacePacketParser = void 0;\nconst stream_1 = require(\"stream\");\nconst utils_1 = require(\"./utils\");\n/**\n * A Transform stream that accepts a stream of octet data and converts it into an object\n * representation of a CCSDS Space Packet. See https://public.ccsds.org/Pubs/133x0b2e1.pdf for a\n * description of the Space Packet format.\n */\nclass SpacePacketParser extends stream_1.Transform {\n  timeCodeFieldLength;\n  ancillaryDataFieldLength;\n  dataBuffer;\n  headerBuffer;\n  dataLength;\n  expectingHeader;\n  dataSlice;\n  header;\n  /**\n   * A Transform stream that accepts a stream of octet data and emits object representations of\n   * CCSDS Space Packets once a packet has been completely received.\n   * @param {Object} [options] Configuration options for the stream\n   * @param {Number} options.timeCodeFieldLength The length of the time code field within the data\n   * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data\n   */\n  constructor(options = {}) {\n    super({\n      ...options,\n      objectMode: true\n    });\n    // Set the constants for this Space Packet Connection; these will help us parse incoming data\n    // fields:\n    this.timeCodeFieldLength = options.timeCodeFieldLength || 0;\n    this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;\n    this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;\n    // These are stateful based on the current packet being received:\n    this.dataBuffer = Buffer.alloc(0);\n    this.headerBuffer = Buffer.alloc(0);\n    this.dataLength = 0;\n    this.expectingHeader = true;\n  }\n  /**\n   * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.\n   * If more data has been received past the current packet, begin the process of parsing the next\n   * packet(s).\n   */\n  pushCompletedPacket() {\n    if (!this.header) {\n      throw new Error('Missing header');\n    }\n    const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));\n    const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));\n    const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));\n    const completedPacket = {\n      header: {\n        ...this.header\n      },\n      data: data.toString()\n    };\n    if (timeCode.length > 0 || ancillaryData.length > 0) {\n      completedPacket.secondaryHeader = {};\n      if (timeCode.length) {\n        completedPacket.secondaryHeader.timeCode = timeCode.toString();\n      }\n      if (ancillaryData.length) {\n        completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();\n      }\n    }\n    this.push(completedPacket);\n    // If there is an overflow (i.e. we have more data than the packet we just pushed) begin parsing\n    // the next packet.\n    const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));\n    if (nextChunk.length >= utils_1.HEADER_LENGTH) {\n      this.extractHeader(nextChunk);\n    } else {\n      this.headerBuffer = nextChunk;\n      this.dataBuffer = Buffer.alloc(0);\n      this.expectingHeader = true;\n      this.dataLength = 0;\n      this.header = undefined;\n    }\n  }\n  /**\n   * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it\n   * if it's complete. If there's more to the chunk than just the header, initiate handling the\n   * packet data.\n   * @param chunk -  Build the Stream's headerBuffer property from\n   */\n  extractHeader(chunk) {\n    const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);\n    const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);\n    if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {\n      this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);\n      this.dataLength = this.header.dataLength;\n      this.headerBuffer = Buffer.alloc(0);\n      this.expectingHeader = false;\n    } else {\n      this.headerBuffer = headerAsBuffer;\n    }\n    if (startOfDataBuffer.length > 0) {\n      this.dataBuffer = Buffer.from(startOfDataBuffer);\n      if (this.dataBuffer.length >= this.dataLength) {\n        this.pushCompletedPacket();\n      }\n    }\n  }\n  _transform(chunk, encoding, cb) {\n    if (this.expectingHeader) {\n      this.extractHeader(chunk);\n    } else {\n      this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);\n      if (this.dataBuffer.length >= this.dataLength) {\n        this.pushCompletedPacket();\n      }\n    }\n    cb();\n  }\n  _flush(cb) {\n    const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);\n    const remainingArray = Array.from(remaining);\n    this.push(remainingArray);\n    cb();\n  }\n}\nexports.SpacePacketParser = SpacePacketParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","SpacePacketParser","stream_1","require","utils_1","Transform","timeCodeFieldLength","ancillaryDataFieldLength","dataBuffer","headerBuffer","dataLength","expectingHeader","dataSlice","header","constructor","options","objectMode","Buffer","alloc","pushCompletedPacket","Error","timeCode","from","slice","ancillaryData","data","completedPacket","toString","length","secondaryHeader","push","nextChunk","HEADER_LENGTH","extractHeader","undefined","chunk","headerAsBuffer","concat","startOfDataBuffer","convertHeaderBufferToObj","_transform","encoding","cb","_flush","remaining","remainingArray","Array"],"sources":["/Users/kimdoyeon/Desktop/CapstonDesign1/node_modules/@serialport/parser-spacepacket/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SpacePacketParser = void 0;\nconst stream_1 = require(\"stream\");\nconst utils_1 = require(\"./utils\");\n/**\n * A Transform stream that accepts a stream of octet data and converts it into an object\n * representation of a CCSDS Space Packet. See https://public.ccsds.org/Pubs/133x0b2e1.pdf for a\n * description of the Space Packet format.\n */\nclass SpacePacketParser extends stream_1.Transform {\n    timeCodeFieldLength;\n    ancillaryDataFieldLength;\n    dataBuffer;\n    headerBuffer;\n    dataLength;\n    expectingHeader;\n    dataSlice;\n    header;\n    /**\n     * A Transform stream that accepts a stream of octet data and emits object representations of\n     * CCSDS Space Packets once a packet has been completely received.\n     * @param {Object} [options] Configuration options for the stream\n     * @param {Number} options.timeCodeFieldLength The length of the time code field within the data\n     * @param {Number} options.ancillaryDataFieldLength The length of the ancillary data field within the data\n     */\n    constructor(options = {}) {\n        super({ ...options, objectMode: true });\n        // Set the constants for this Space Packet Connection; these will help us parse incoming data\n        // fields:\n        this.timeCodeFieldLength = options.timeCodeFieldLength || 0;\n        this.ancillaryDataFieldLength = options.ancillaryDataFieldLength || 0;\n        this.dataSlice = this.timeCodeFieldLength + this.ancillaryDataFieldLength;\n        // These are stateful based on the current packet being received:\n        this.dataBuffer = Buffer.alloc(0);\n        this.headerBuffer = Buffer.alloc(0);\n        this.dataLength = 0;\n        this.expectingHeader = true;\n    }\n    /**\n     * Bundle the header, secondary header if present, and the data into a JavaScript object to emit.\n     * If more data has been received past the current packet, begin the process of parsing the next\n     * packet(s).\n     */\n    pushCompletedPacket() {\n        if (!this.header) {\n            throw new Error('Missing header');\n        }\n        const timeCode = Buffer.from(this.dataBuffer.slice(0, this.timeCodeFieldLength));\n        const ancillaryData = Buffer.from(this.dataBuffer.slice(this.timeCodeFieldLength, this.timeCodeFieldLength + this.ancillaryDataFieldLength));\n        const data = Buffer.from(this.dataBuffer.slice(this.dataSlice, this.dataLength));\n        const completedPacket = {\n            header: { ...this.header },\n            data: data.toString(),\n        };\n        if (timeCode.length > 0 || ancillaryData.length > 0) {\n            completedPacket.secondaryHeader = {};\n            if (timeCode.length) {\n                completedPacket.secondaryHeader.timeCode = timeCode.toString();\n            }\n            if (ancillaryData.length) {\n                completedPacket.secondaryHeader.ancillaryData = ancillaryData.toString();\n            }\n        }\n        this.push(completedPacket);\n        // If there is an overflow (i.e. we have more data than the packet we just pushed) begin parsing\n        // the next packet.\n        const nextChunk = Buffer.from(this.dataBuffer.slice(this.dataLength));\n        if (nextChunk.length >= utils_1.HEADER_LENGTH) {\n            this.extractHeader(nextChunk);\n        }\n        else {\n            this.headerBuffer = nextChunk;\n            this.dataBuffer = Buffer.alloc(0);\n            this.expectingHeader = true;\n            this.dataLength = 0;\n            this.header = undefined;\n        }\n    }\n    /**\n     * Build the Stream's headerBuffer property from the received Buffer chunk; extract data from it\n     * if it's complete. If there's more to the chunk than just the header, initiate handling the\n     * packet data.\n     * @param chunk -  Build the Stream's headerBuffer property from\n     */\n    extractHeader(chunk) {\n        const headerAsBuffer = Buffer.concat([this.headerBuffer, chunk]);\n        const startOfDataBuffer = headerAsBuffer.slice(utils_1.HEADER_LENGTH);\n        if (headerAsBuffer.length >= utils_1.HEADER_LENGTH) {\n            this.header = (0, utils_1.convertHeaderBufferToObj)(headerAsBuffer);\n            this.dataLength = this.header.dataLength;\n            this.headerBuffer = Buffer.alloc(0);\n            this.expectingHeader = false;\n        }\n        else {\n            this.headerBuffer = headerAsBuffer;\n        }\n        if (startOfDataBuffer.length > 0) {\n            this.dataBuffer = Buffer.from(startOfDataBuffer);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.expectingHeader) {\n            this.extractHeader(chunk);\n        }\n        else {\n            this.dataBuffer = Buffer.concat([this.dataBuffer, chunk]);\n            if (this.dataBuffer.length >= this.dataLength) {\n                this.pushCompletedPacket();\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        const remaining = Buffer.concat([this.headerBuffer, this.dataBuffer]);\n        const remainingArray = Array.from(remaining);\n        this.push(remainingArray);\n        cb();\n    }\n}\nexports.SpacePacketParser = SpacePacketParser;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}