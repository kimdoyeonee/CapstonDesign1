{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SlipDecoder = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes slip encoded data.\n * @extends Transform\n *\n * Runs in O(n) time, stripping out slip encoding and emitting decoded data. Optionally custom slip escape and delimiters can be provided.\n */\nclass SlipDecoder extends stream_1.Transform {\n  opts;\n  buffer;\n  escape;\n  start;\n  constructor(options = {}) {\n    super(options);\n    const {\n      START,\n      ESC = 0xdb,\n      END = 0xc0,\n      ESC_START,\n      ESC_END = 0xdc,\n      ESC_ESC = 0xdd\n    } = options;\n    this.opts = {\n      START,\n      ESC,\n      END,\n      ESC_START,\n      ESC_END,\n      ESC_ESC\n    };\n    this.buffer = Buffer.alloc(0);\n    this.escape = false;\n    this.start = false;\n  }\n  _transform(chunk, encoding, cb) {\n    for (let ndx = 0; ndx < chunk.length; ndx++) {\n      let byte = chunk[ndx];\n      if (byte === this.opts.START) {\n        this.start = true;\n        continue;\n      } else if (undefined == this.opts.START) {\n        this.start = true;\n      }\n      if (this.escape) {\n        if (byte === this.opts.ESC_START && this.opts.START) {\n          byte = this.opts.START;\n        } else if (byte === this.opts.ESC_ESC) {\n          byte = this.opts.ESC;\n        } else if (byte === this.opts.ESC_END) {\n          byte = this.opts.END;\n        } else {\n          this.escape = false;\n          this.push(this.buffer);\n          this.buffer = Buffer.alloc(0);\n        }\n      } else {\n        if (byte === this.opts.ESC) {\n          this.escape = true;\n          continue;\n        }\n        if (byte === this.opts.END) {\n          this.push(this.buffer);\n          this.buffer = Buffer.alloc(0);\n          this.escape = false;\n          this.start = false;\n          continue;\n        }\n      }\n      this.escape = false;\n      if (this.start) {\n        this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n      }\n    }\n    cb();\n  }\n  _flush(cb) {\n    this.push(this.buffer);\n    this.buffer = Buffer.alloc(0);\n    cb();\n  }\n}\nexports.SlipDecoder = SlipDecoder;","map":{"version":3,"names":["Object","defineProperty","exports","value","SlipDecoder","stream_1","require","Transform","opts","buffer","escape","start","constructor","options","START","ESC","END","ESC_START","ESC_END","ESC_ESC","Buffer","alloc","_transform","chunk","encoding","cb","ndx","length","byte","undefined","push","concat","from","_flush"],"sources":["/Users/kimdoyeon/Desktop/CapstonDesign1/node_modules/@serialport/parser-slip-encoder/dist/decoder.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SlipDecoder = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that decodes slip encoded data.\n * @extends Transform\n *\n * Runs in O(n) time, stripping out slip encoding and emitting decoded data. Optionally custom slip escape and delimiters can be provided.\n */\nclass SlipDecoder extends stream_1.Transform {\n    opts;\n    buffer;\n    escape;\n    start;\n    constructor(options = {}) {\n        super(options);\n        const { START, ESC = 0xdb, END = 0xc0, ESC_START, ESC_END = 0xdc, ESC_ESC = 0xdd } = options;\n        this.opts = {\n            START,\n            ESC,\n            END,\n            ESC_START,\n            ESC_END,\n            ESC_ESC,\n        };\n        this.buffer = Buffer.alloc(0);\n        this.escape = false;\n        this.start = false;\n    }\n    _transform(chunk, encoding, cb) {\n        for (let ndx = 0; ndx < chunk.length; ndx++) {\n            let byte = chunk[ndx];\n            if (byte === this.opts.START) {\n                this.start = true;\n                continue;\n            }\n            else if (undefined == this.opts.START) {\n                this.start = true;\n            }\n            if (this.escape) {\n                if (byte === this.opts.ESC_START && this.opts.START) {\n                    byte = this.opts.START;\n                }\n                else if (byte === this.opts.ESC_ESC) {\n                    byte = this.opts.ESC;\n                }\n                else if (byte === this.opts.ESC_END) {\n                    byte = this.opts.END;\n                }\n                else {\n                    this.escape = false;\n                    this.push(this.buffer);\n                    this.buffer = Buffer.alloc(0);\n                }\n            }\n            else {\n                if (byte === this.opts.ESC) {\n                    this.escape = true;\n                    continue;\n                }\n                if (byte === this.opts.END) {\n                    this.push(this.buffer);\n                    this.buffer = Buffer.alloc(0);\n                    this.escape = false;\n                    this.start = false;\n                    continue;\n                }\n            }\n            this.escape = false;\n            if (this.start) {\n                this.buffer = Buffer.concat([this.buffer, Buffer.from([byte])]);\n            }\n        }\n        cb();\n    }\n    _flush(cb) {\n        this.push(this.buffer);\n        this.buffer = Buffer.alloc(0);\n        cb();\n    }\n}\nexports.SlipDecoder = SlipDecoder;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}