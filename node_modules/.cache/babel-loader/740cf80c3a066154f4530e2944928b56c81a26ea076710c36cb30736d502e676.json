{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReadyParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n *\n * To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n */\nclass ReadyParser extends stream_1.Transform {\n  delimiter;\n  readOffset;\n  ready;\n  constructor({\n    delimiter,\n    ...options\n  }) {\n    if (delimiter === undefined) {\n      throw new TypeError('\"delimiter\" is not a bufferable object');\n    }\n    if (delimiter.length === 0) {\n      throw new TypeError('\"delimiter\" has a 0 or undefined length');\n    }\n    super(options);\n    this.delimiter = Buffer.from(delimiter);\n    this.readOffset = 0;\n    this.ready = false;\n  }\n  _transform(chunk, encoding, cb) {\n    if (this.ready) {\n      this.push(chunk);\n      return cb();\n    }\n    const delimiter = this.delimiter;\n    let chunkOffset = 0;\n    while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n      if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n        this.readOffset++;\n      } else {\n        this.readOffset = 0;\n      }\n      chunkOffset++;\n    }\n    if (this.readOffset === delimiter.length) {\n      this.ready = true;\n      this.emit('ready');\n      const chunkRest = chunk.slice(chunkOffset);\n      if (chunkRest.length > 0) {\n        this.push(chunkRest);\n      }\n    }\n    cb();\n  }\n}\nexports.ReadyParser = ReadyParser;","map":{"version":3,"names":["Object","defineProperty","exports","value","ReadyParser","stream_1","require","Transform","delimiter","readOffset","ready","constructor","options","undefined","TypeError","length","Buffer","from","_transform","chunk","encoding","cb","push","chunkOffset","emit","chunkRest","slice"],"sources":["/Users/kimdoyeon/Desktop/CapstonDesign1/node_modules/@serialport/parser-ready/dist/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadyParser = void 0;\nconst stream_1 = require(\"stream\");\n/**\n * A transform stream that waits for a sequence of \"ready\" bytes before emitting a ready event and emitting data events\n *\n * To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.\n */\nclass ReadyParser extends stream_1.Transform {\n    delimiter;\n    readOffset;\n    ready;\n    constructor({ delimiter, ...options }) {\n        if (delimiter === undefined) {\n            throw new TypeError('\"delimiter\" is not a bufferable object');\n        }\n        if (delimiter.length === 0) {\n            throw new TypeError('\"delimiter\" has a 0 or undefined length');\n        }\n        super(options);\n        this.delimiter = Buffer.from(delimiter);\n        this.readOffset = 0;\n        this.ready = false;\n    }\n    _transform(chunk, encoding, cb) {\n        if (this.ready) {\n            this.push(chunk);\n            return cb();\n        }\n        const delimiter = this.delimiter;\n        let chunkOffset = 0;\n        while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {\n            if (delimiter[this.readOffset] === chunk[chunkOffset]) {\n                this.readOffset++;\n            }\n            else {\n                this.readOffset = 0;\n            }\n            chunkOffset++;\n        }\n        if (this.readOffset === delimiter.length) {\n            this.ready = true;\n            this.emit('ready');\n            const chunkRest = chunk.slice(chunkOffset);\n            if (chunkRest.length > 0) {\n                this.push(chunkRest);\n            }\n        }\n        cb();\n    }\n}\nexports.ReadyParser = ReadyParser;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAG,KAAK,CAAC;AAC5B,MAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAClC;AACA;AACA;AACA;AACA;AACA,MAAMF,WAAW,SAASC,QAAQ,CAACE,SAAS,CAAC;EACzCC,SAAS;EACTC,UAAU;EACVC,KAAK;EACLC,WAAWA,CAAC;IAAEH,SAAS;IAAE,GAAGI;EAAQ,CAAC,EAAE;IACnC,IAAIJ,SAAS,KAAKK,SAAS,EAAE;MACzB,MAAM,IAAIC,SAAS,CAAC,wCAAwC,CAAC;IACjE;IACA,IAAIN,SAAS,CAACO,MAAM,KAAK,CAAC,EAAE;MACxB,MAAM,IAAID,SAAS,CAAC,yCAAyC,CAAC;IAClE;IACA,KAAK,CAACF,OAAO,CAAC;IACd,IAAI,CAACJ,SAAS,GAAGQ,MAAM,CAACC,IAAI,CAACT,SAAS,CAAC;IACvC,IAAI,CAACC,UAAU,GAAG,CAAC;IACnB,IAAI,CAACC,KAAK,GAAG,KAAK;EACtB;EACAQ,UAAUA,CAACC,KAAK,EAAEC,QAAQ,EAAEC,EAAE,EAAE;IAC5B,IAAI,IAAI,CAACX,KAAK,EAAE;MACZ,IAAI,CAACY,IAAI,CAACH,KAAK,CAAC;MAChB,OAAOE,EAAE,CAAC,CAAC;IACf;IACA,MAAMb,SAAS,GAAG,IAAI,CAACA,SAAS;IAChC,IAAIe,WAAW,GAAG,CAAC;IACnB,OAAO,IAAI,CAACd,UAAU,GAAGD,SAAS,CAACO,MAAM,IAAIQ,WAAW,GAAGJ,KAAK,CAACJ,MAAM,EAAE;MACrE,IAAIP,SAAS,CAAC,IAAI,CAACC,UAAU,CAAC,KAAKU,KAAK,CAACI,WAAW,CAAC,EAAE;QACnD,IAAI,CAACd,UAAU,EAAE;MACrB,CAAC,MACI;QACD,IAAI,CAACA,UAAU,GAAG,CAAC;MACvB;MACAc,WAAW,EAAE;IACjB;IACA,IAAI,IAAI,CAACd,UAAU,KAAKD,SAAS,CAACO,MAAM,EAAE;MACtC,IAAI,CAACL,KAAK,GAAG,IAAI;MACjB,IAAI,CAACc,IAAI,CAAC,OAAO,CAAC;MAClB,MAAMC,SAAS,GAAGN,KAAK,CAACO,KAAK,CAACH,WAAW,CAAC;MAC1C,IAAIE,SAAS,CAACV,MAAM,GAAG,CAAC,EAAE;QACtB,IAAI,CAACO,IAAI,CAACG,SAAS,CAAC;MACxB;IACJ;IACAJ,EAAE,CAAC,CAAC;EACR;AACJ;AACAnB,OAAO,CAACE,WAAW,GAAGA,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}